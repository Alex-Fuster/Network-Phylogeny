---
title: "Obtain phylogenetic and interaction distances"
output: html_notebook
---

```{r}
#source("../Original_code/functions/tree_functions.R")
#source("../Original_code/functions/phylo_functions.R")
source("functions/functions_phylo_signal.R")
library(ape)
library(apTreeshape)
library(aricode)
library(igraph)
library(ggplot2)
library("vegan")
```




### Load simulation data


FOODWEB

```{r}

list_res <- readRDS("../data/selection_evolution/foodweb1/fw.rds")




#names(list_res) = c("simulation1", "simulation2")

list_simulation1 <- list_res

names(list_simulation1)[1] <- "presence_matrix"
names(list_simulation1)[7] <- "network_list"
names(list_simulation1)[9] <- "list_anc_dist"


# count number of timesteps where there were spp

n_steps <- length(list_simulation1$network_list)


```

COMPETITION

```{r}

list_res <- readRDS("../Data/selection_evolution/competition/list_res_neg_2.rds")


# count number of timesteps where there were spp

list_simulation1 <- list_res

n_steps <- length(list_simulation1$network_list)

```


FACILITATION

```{r}

list_res <- readRDS("../Data/selection_evolution/facilitation/list_res_pos_2.rds")


# count number of timesteps where there were spp

list_simulation1 <- list_res

n_steps <- length(list_simulation1$network_list)


```



NEUTRAL

```{r}

load("../data/neutral/list_res_neutral_1.Rdata")

list <- list_objects_sc[[1]]

list_simulation1 <- list[[1]]


# count number of timesteps where there were spp

n_steps <- length(list_simulation1$network_list)

```




The presence_matrix (rows = timesteps, cols = species, entries = 1,0) has extra timesteps in case the simulation is longer (max = 350), so I crop it to the number of timesteps in the simulation:

```{r}

presence_matrix <- list_simulation1$presence_matrix

presence_matrix <- presence_matrix[1:n_steps,]

```



#### Identify timesteps where phylogenetic distances cant be calculated

It requires at leas 3 species to compute the phylogenetic distances.
Check the timestep from which we can make the calculations by looking at the presence_matrix and see which matrices (or timesteps) have less than 3 spp.

```{r}

non.valid_timesteps_phylo_distance <- c(which(rowSums(presence_matrix) < 3))

# until what timestep need to discard:

final.discarded_timestep <- non.valid_timesteps_phylo_distance[length(non.valid_timesteps_phylo_distance)]

print(paste("timesteps 1 to", final.discarded_timestep, "will be discarted as they have less than 3 spp"))

```




#### homogenize elements to start from valid timesteps

Discard those timesteps with less than 3 spp in both the list_anc_dist table (ancestry table) and the network_list:

```{r}

# ancestry-distances table

list_anc_dist <- list_simulation1$list_anc_dist[(final.discarded_timestep+1):length(list_simulation1$list_anc_dist)]



# Network list

network_list <- list_simulation1$network_list[(final.discarded_timestep+1):length(list_simulation1$list_anc_dist)]







## ------------------- Check

if (length(which(is.null(list_simulation1$network_list))) > 0) {
  
  print("check - null network somewhere")
} else {
  print("all good - no null networks")
}


if(length(list_anc_dist) == length(network_list)){
  
  print("all good - distance-ancestry table and network list have the same length")
} else {
  
  print("PROBLEM")
}


```

ELIMINATE BASALS (foodweb)

```{r}

# discard basals in interaction matrixes

Sbasals <- length(list_simulation1$basal)

network_list <- lapply(network_list, eliminate_basals, nbasals = Sbasals)


```



## Convert spp names from numbers to letters


Species names in both the ancestry table and the networks are numbers. Convert it into letters with the function **change_sppnames_letters_ancdist.table()** for the ancestry table, and **set_sppNames_numbers()** (because matrices lack colnames and rownames) and **convert_sppnames_toletters()** for the network list:

```{r}

## ancestry-distances table

list_anc_dist_letters <- lapply(list_anc_dist, change_sppnames_letters_ancdist.table)


## Network list 


list_networks_sppnames_numbers <- lapply(network_list, set_sppNames_numbers)

#### convert numbers to letters

list_networks_sppnames_letters <- lapply(list_networks_sppnames_numbers, convert_sppnames_toletters)






## ------------------- Check


if(length(list_anc_dist_letters) == length(list_networks_sppnames_letters)){
  
  print("all good - distance-ancestry table with letters and network list with leters have the same length")
} else {
  
  print("PROBLEM")
}


```




## Loop for obtaining phylogenetic distances:


Without distinguishing predators and preys:

```{r}

list_newick <- list()
list_trees <- list()
list_newick_tails <- list()
list_dist.phylo <- list()




for (i in 1:length(list_anc_dist_letters)) {
  
  
  print(sprintf("step %s", i))
  
  list_newick[[i]] <- ToPhylo(list_anc_dist_letters[[i]])
  
  list_newick_tails[[i]] <- paste(list_newick[[i]], "root")
  
  list_trees[[i]] <- read.tree(text = sub("A root",";",list_newick_tails[[i]]))
  
  list_dist.phylo[[i]] <- cophenetic.phylo(list_trees[[i]])
  

}







## ------------------- Check

if (length(which(unlist(lapply(list_dist.phylo, is.null)) == TRUE)) == 0) {
  
  print("all good - no nulls")
} else {
  
  print("PROBLEM")
  
}



if (length(list_dist.phylo) == length(list_networks_sppnames_letters)){
  
  print("all good - list phylo dist with letters and list interactions with letters have the same length")
  
}else{
  
  print("PROBLEM")
  
}


```



## Retain only present species in network matrices

For phylogenetic distance matrices, the spp for which distances are calculated are already only the ones present.

But the interaction matrices are 1000 x 1000 (all spp possible), so I need to crop them to retain only present species at each timestep, and test that these correspond to the ones present in the phylogenetic distance matrices at the corresponding timestep.


I use the presence_matrix to retain the species present at each timestep in each network from the network list. So first I need to convert the spp names of the presence_matrix to letters so that they can match with those of the network. Second, I will discard the timesteps already discarted in the phylogenetic distance matrices list and in the network list so that the presence_matrix match in the length of timesteps with them.


```{r}

# Set the same spp names for the presence_matrix than for the interacion matrices


colnames(presence_matrix) <- seq(1:1000)

colnames(presence_matrix) <- chartr("0123456789", "ABCDEFGHIJ", colnames(presence_matrix))



## ------------------- Check

if(length(which(colnames(presence_matrix) != colnames(list_networks_sppnames_letters[[1]]))) == 0){
  
  print("all good - spp names in presence_matrix correspond to spp names in network list")
  
} else {
  
  print("PROBLEM")
} 





# Discard same timesteps (rows) than the discarted phylogenetic distance matrices

presence_matrix <- presence_matrix[(final.discarded_timestep+1):length(list_simulation1$list_anc_dist),]




## ------------------- Check

if(nrow(presence_matrix) == length(list_networks_sppnames_letters) & 
   nrow(presence_matrix) == length(list_dist.phylo)){
  
  print("all good - presence matrix, list phylo dist and list interaction networks have the same n_steps")
  
} else {
  
  print("PROBLEM")
}




```


Now that the presence_matrix has the spp names with letters and retains the same timesteps than the network list, I will use it to retain only the species present at each timestep in each 1000 x 1000 network:

```{r}

## crop the interaction matrix with present spp

list_net_present_spp.letters <- list()

for (i in 1:length(list_networks_sppnames_letters)) {
  
 list_net_present_spp.letters[[i]] <- list_networks_sppnames_letters[[i]][names(which(presence_matrix[i,] == 1)), names(which(presence_matrix[i,] == 1))]
  
}



```






## Compute interaction distances (NMI)


I will use the function **compute_nmi_aricode_pred()** for predators and **compute_nmi_aricode_prey()** for preys (their differ in whether the NMI is computed for columns or rows, respectively). These compute the NMI using the aricode package.


```{r}


## DISTANCES AS PREDATORS (columns)


#list_interact_distances_pred <- lapply(list_net_present_spp.letters, FUN = compute_nmi_cols)
list_interact_distances_pred <- lapply(list_net_present_spp.letters, FUN = compute_nmi_aricode_pred)


# thosa that are all 0 will have NaN - I need to convert them into 0


## DISTANCES AS PREYS (rows)

#list_interact_distances_prey <- lapply(list_net_present_spp.letters, FUN = compute_nmi_rows)
list_interact_distances_prey <- lapply(list_net_present_spp.letters, FUN = compute_nmi_aricode_prey)



```


Some species have NAN in their diagonal. I make sure this doesnt happen by setting the diagonal to ones with the function **diag_to0()**:


```{r}

list_interact_distances_pred <- lapply(list_interact_distances_pred, FUN = diag_to0)

list_interact_distances_prey <- lapply(list_interact_distances_prey, FUN = diag_to0)

```



Now I have the phylogenetic distance matrices in list_dist.phylo, and the interaction distances in list_interact_distances_pred, list_interact_distances_prey, and list_interact_distances_mean.


Check that both the list of distance matrices for interactions and for phylogeny have the same length:

```{r}


if(length(list_dist.phylo) == length(list_interact_distances_pred) &
   length(list_dist.phylo) == length(list_interact_distances_prey)) {
  
  print("all good - list phylo dist and lists interact dist have the same length")
  
} else {
  
  print("PROBLEM")
  
}


```


Phylogenetic distance matrices retain the extinct species together with the present ones. The following code is just a demonstration:

```{r}

df.test.phylo <- as.data.frame(list_dist.phylo[[15]])
df.test.int <- as.data.frame(list_interact_distances_pred[[15]])

data_new.phylo <- df.test.phylo[order(names(df.test.phylo)) , order(names(df.test.phylo))]
data_new.int <- df.test.int[order(names(df.test.int)) , order(names(df.test.int))]

length(colnames(data_new.int)) == length(colnames(data_new.phylo))

```

Therefore, I need to retain only present species in the phylogenetic distance matrices. 




## For phylogenetic distance matrices, retain only those species present

To do this,

- 1st - order the names of columns and rows of both phylogenetic and interaction distance matrices so that they coincide
- 2nd - Retain in the phylo-distance matrix only those species names that the interaction distance matrix has. This way, I will be retaining only the present species (remember the interaction distance matrices have already retained the present species only when we used the presence_matrix for it)



```{r}

list_dist.phylo_pres <- list()

for (i in 1:length(list_dist.phylo)) {
  
  spp_present <- colnames(list_interact_distances_pred[[i]])
  list_dist.phylo_pres[[i]] <- list_dist.phylo[[i]][spp_present ,spp_present] 
  
  
}


```



```{r}


## Check that now phylo and interaction distance matrices have the same number of spp, same names, and in the same order


if (length(which(check_colnames_lists(list_dist.phylo_pres, list_interact_distances_pred) == FALSE)) == 0) {
  
  print("all good - names in phylo dist matrices and interaction matrices pred match")
  
} else {
  
  print("PROBLEM")
  
}


if (length(which(check_colnames_lists(list_dist.phylo_pres, list_interact_distances_prey) == FALSE)) == 0) {
  
  print("all good - names in phylo dist matrices and interaction matrices prey match")
  
} else {
  
  print("PROBLEM")
  
}




```


NOW I'M READY TO COMPUTE CORRELATION



# Compute MDS


First, I need to solve the following problem:

Some species have all 0 in their interactions (either as prey (if all 0 in the row, top predators) or predators (if all 0 in the column, basal spp)). When two spp having all 0 compare with each other, they give NaN instead of 0 (the (1-NMI) should be 0 as they have the same vector of interactions).

Therefore, I assign a 0 to all NaN found.

[[ CHECK THIS ]]


```{r}

list_interact_distances_pred_corrected <- list()

for (i in 1:length(list_interact_distances_pred)) {
  
  list_interact_distances_pred_corrected[[i]] <- convet_nan_to_0_matrix(matrix = list_interact_distances_pred[[i]],
                       marg = 2) # 1 (rows), 2 (col), or c(1,2)
  
}


list_interact_distances_prey_corrected <- list()

for (i in 1:length(list_interact_distances_prey)) {
  
  list_interact_distances_prey_corrected[[i]] <- convet_nan_to_0_matrix(matrix = list_interact_distances_prey[[i]],
                       marg = 1) # 1 (rows), 2 (col), or c(1,2)
  
}



if(length(list_interact_distances_prey_corrected) == length(list_interact_distances_pred_corrected) &
   length(list_interact_distances_prey_corrected) == length(list_dist.phylo_pres)){
  
  print("all good - lists of phylo dist and interactions have the same length")
  
} else {
  
  print("PROBLEM")
  
}


```


To compute the overall distances between species I calculate the mean between the distances as preys and as predators. I do this by looping through the lists (predator distance matrices list, prey distance matrices list), so selecting one matric from each at a given timestep, and computing the mean between them with the function **compute_mean_two_mat_from_list()**:

```{r}

list_interact_distances_mean_corrected <- list()


for (i in 1:length(list_interact_distances_pred_corrected)) {
  
 pair_mat <- list(list_interact_distances_pred_corrected[[i]], list_interact_distances_prey_corrected[[i]])
  
 list_interact_distances_mean_corrected[[i]] <- compute_mean_two_mat_from_list(list = pair_mat)
  
}


if(length(list_interact_distances_mean_corrected) == length(list_dist.phylo_pres)){
  
  print("all good - lists of phylo dist and mean interactions have the same length")
  
} else {
  
  print("PROBLEM")
  
}

```


Now I can compute the MDS:


```{r}

# compute mds

list_mds.phy <- list()
list_mds.int_pred <- list()
list_mds.int_prey <- list()
list_mds.int_mean <- list()

#list_interact_distances_pred_corrected <- list_interact_distances_pred_corrected[-1]
#list_interact_distances_prey_corrected <- list_interact_distances_prey_corrected[-1]
#list_interact_distances_mean_corrected <- list_interact_distances_mean_corrected[-1]

#list_dist.phylo_pres <- list_dist.phylo_pres[-1]




for (i in 1:length(list_dist.phylo_pres)) {

list_mds.phy[[i]] <- monoMDS(list_dist.phylo_pres[[i]], y = cmdscale(list_dist.phylo_pres[[i]])) 

list_mds.int_pred[[i]] <- monoMDS(list_interact_distances_pred_corrected[[i]], y = cmdscale(list_interact_distances_pred_corrected[[i]]))

list_mds.int_prey[[i]] <- monoMDS(list_interact_distances_prey_corrected[[i]], y = cmdscale(list_interact_distances_prey_corrected[[i]]))

list_mds.int_mean[[i]] <- monoMDS(list_interact_distances_mean_corrected[[i]], y = cmdscale(list_interact_distances_mean_corrected[[i]]))


  
}



```

Sometimes there are matrices of interaction distances with all 0 (why(?)). If so, the above code gives an error. If so, run this:

```{r}

### Check what matrices of interactions have all 0 and discard them

check_matrix.with.values <- function(matrix) {
  
  result <- any(matrix != 0)
  
  return(result)
  
}

list_interact_distances_pred_corrected1 <- list_interact_distances_pred_corrected[-which(lapply(list_interact_distances_pred_corrected,check_matrix.with.values) != TRUE)]

list_interact_distances_prey_corrected1 <- list_interact_distances_prey_corrected[-which(lapply(list_interact_distances_prey_corrected,check_matrix.with.values) != TRUE)]

list_interact_distances_mean_corrected1 <- list_interact_distances_mean_corrected[-which(lapply(list_interact_distances_mean_corrected,check_matrix.with.values) != TRUE)]

list_dist.phylo_pres1 <- list_dist.phylo_pres[-which(lapply(list_interact_distances_mean_corrected,check_matrix.with.values) != TRUE)]



for (i in 1:length(list_dist.phylo_pres1)) {

list_mds.phy[[i]] <- monoMDS(list_dist.phylo_pres1[[i]], y = cmdscale(list_dist.phylo_pres1[[i]])) 

list_mds.int_pred[[i]] <- monoMDS(list_interact_distances_pred_corrected1[[i]], y = cmdscale(list_interact_distances_pred_corrected1[[i]]))

list_mds.int_prey[[i]] <- monoMDS(list_interact_distances_prey_corrected1[[i]], y = cmdscale(list_interact_distances_prey_corrected1[[i]]))

list_mds.int_mean[[i]] <- monoMDS(list_interact_distances_mean_corrected1[[i]], y = cmdscale(list_interact_distances_mean_corrected1[[i]]))


  
}
```





# Compute correlation - Procrustes test

I compute a procrustes correlation between interaction distances as predators, preys, or the mean, and the phylogenetic distances. To do this, I use the **protest** and **procrustes** functions from the vegan package.


```{r}

protest_pred <- list()
procrustes_pred <- list()

protest_prey <- list()
procrustes_prey <- list()

protest_mean <- list()
procrustes_mean <- list()


for (i in 1:length(list_dist.phylo_pres)) {
  
  protest_pred[[i]] <- protest(list_mds.int_pred[[i]], list_mds.phy[[i]])
  
  procrustes_pred[[i]] <- procrustes(list_mds.int_pred[[i]],list_mds.phy[[i]])
  
  
}

for (i in 1:length(list_dist.phylo_pres)) {
  
  protest_prey[[i]] <- protest(list_mds.int_prey[[i]], list_mds.phy[[i]])
  
  procrustes_prey[[i]] <- procrustes(list_mds.int_prey[[i]],list_mds.phy[[i]])
  
  
}

for (i in 1:length(list_dist.phylo_pres)) {
  
  protest_mean[[i]] <- protest(list_mds.int_mean[[i]], list_mds.phy[[i]])
  
  procrustes_mean[[i]] <- procrustes(list_mds.int_mean[[i]],list_mds.phy[[i]])
  
  
}


```



## Create dataframe results


I store the correlation and Pvalue from the tests.


```{r}

protest_pval_pred <- c()
protest_corr_pred <- c()
protest_t_pred <- c()

protest_pval_prey <- c()
protest_corr_prey <- c()
protest_t_prey <- c()

protest_pval_mean <- c()
protest_corr_mean <- c()
protest_t_mean <- c()

for (i in 1:length(protest_mean)) {
  
  protest_pval_pred[i] <- protest_pred[[i]]$signif
  
  protest_corr_pred[i] <-protest_pred[[i]]$t0
  
  protest_t_pred[i] <-mean(protest_pred[[i]]$t)
  
  
  protest_pval_prey[i] <- protest_prey[[i]]$signif
  
  protest_corr_prey[i] <-protest_prey[[i]]$t0
  
  protest_t_prey[i] <-mean(protest_prey[[i]]$t)
  
  
  protest_pval_mean[i] <- protest_mean[[i]]$signif
  
  protest_corr_mean[i] <-protest_mean[[i]]$t0
  
  protest_t_mean[i] <-mean(protest_mean[[i]]$t)
  
  
}

discarted_timesteps <- length(list_simulation1$network_list) - length(protest_mean)

timesteps = (discarted_timesteps+1):length(list_simulation1$network_list)


df_signal_time <- data.frame(timesteps,
                            protest_pval_pred,protest_corr_pred,protest_t_pred,
                            protest_pval_prey,protest_corr_prey,protest_t_prey,
                             protest_pval_mean,protest_corr_mean,protest_t_mean)

df_signal_time$sign_pred <- with(df_signal_time, ifelse(protest_pval_pred < 0.051, 'sign', 'non.sign'))
df_signal_time$sign_prey <- with(df_signal_time, ifelse(protest_pval_prey < 0.051, 'sign', 'non.sign'))
df_signal_time$sign_mean <- with(df_signal_time, ifelse(protest_pval_mean < 0.051, 'sign', 'non.sign'))


df_signal_time


```





```{r}

#save(df_signal_time, file = "../foodweb_test/df_signal_time_competition.RData")

load("../code/foodweb_test/df_signal_time_competition.RData")

df_signal_time

```



```{r}

#save(df_signal_time, file = "../data/selection_evolution/foodweb1/df_signal_time.Rdata")

#load("../foodweb_test/df_signal_time_facilitation.RData")

#df_signal_time

```

```{r}

#save(df_signal_time, file = "../data/neutral/df_signal_time.RData")

load("../data/neutral/df_signal_time.RData")

df_signal_time

```

### Plot phylogenetic signal through time

```{r}


my.theme<-theme(axis.text=element_text(size=12),
                axis.title = element_text(size = 14),
                legend.position = "top",
                legend.text=element_text(size=10),
                legend.title = element_text(size=12),
                plot.title = element_text(face="bold",size=14,margin=margin(0,0,20,0),hjust = 0.5),
                axis.title.y = element_text(margin = margin(t = 0, r = 15, b = 0, l = 0)),
                axis.title.x = element_text(margin = margin(t = 15, r = 0, b = 0, l = 0)))


p_pred <- ggplot(df_signal_time, aes(x=timesteps, y=protest_t_mean)) +
       geom_line(color="black", linetype="twodash")+
  #geom_point(aes(fill = sign_mean, color=sign_mean), size=2, alpha = 0.7) +
  theme_bw()+
    my.theme+
    scale_colour_manual(values = c("black", "red"))+
    ggtitle("as predators")+
xlab("timesteps")+
  ylab("Phylogenetic signal")


p_prey <- ggplot(df_signal_time, aes(x=timesteps, y=protest_t_mean)) +
       geom_line(color="black", linetype="twodash")+
  #geom_point(aes(fill = sign_mean, color=sign_mean), size=2, alpha = 0.7) +
  theme_bw()+
    my.theme+
    scale_colour_manual(values = c("black", "red"))+
    ggtitle("as preys")+
xlab("timesteps")+
  ylab("Phylogenetic signal")

p_mean <- ggplot(df_signal_time, aes(x=timesteps, y=protest_corr_mean)) +
       geom_line(color="black", linetype="twodash")+
  #geom_point(aes(fill = sign_mean, color=sign_mean), size=2, alpha = 0.7) +
  theme_bw()+
    my.theme+
    scale_colour_manual(values = c("black", "red"))+
    ggtitle("foodweb")+
xlab("timesteps")+
  ylab("Phylogenetic signal")




cor(df_signal_time$timesteps, df_signal_time$protest_corr_mean )

```



### Plot species richness through time

```{r}
# SHOW ALSO NUMBER OF SPECIES IN THE GRAPH


n_spp_time <- c()

for (i in 1:nrow(presence_matrix)) {
  
  n_spp_time[i] <- length(which(presence_matrix[i,] == 1))
  
}

df_signal_time$nspp <- n_spp_time


p.spp <- ggplot(df_signal_time, aes(x=timesteps, y = nspp)) +
  geom_line(color="black", linetype="twodash") +
  theme_bw()+
  my.theme+
  scale_colour_manual(values = c("black", "red"))+
  xlab("timesteps")+
  ylab("N species")

p.spp

```




```{r}

library(ggpubr)

ggarrange(p_mean + rremove("xlab"), p.spp, 
             ncol = 1, nrow = 2
             )

ggsave("foodweb_result_phylo.time_1sim.png", 
       height = 7,
       width = 7)

#ggarrange(p_prey + rremove("xlab"),
         # p_pred + rremove("xlab"),
#  p_mean + rremove("xlab"), p.spp, 
       #      ncol = 1, nrow = 4)

#ggsave("figures/foodweb_all_result_phylo.time_1sim.png", 
       #height = 14,
       #width = 7)

```


#### Trying something - relationship between spp degree and phylogenetic signal


```{r}

trial <- procrustes(list_mds.int_mean[[length(list_mds.int_mean)]], list_mds.phy[[length(list_mds.phy)]])


vec_residuals <- residuals(trial, kind = 2)


test_mat <- list_net_present_spp.letters[[length(list_net_present_spp.letters)]]

graph <- graph_from_adjacency_matrix(adjmatrix = test_mat,
                                         mode = "directed")

vec_degree <- degree(graph)


df <- as.data.frame(vec_degree,vec_residuals)


p_timestep_f <- ggplot(df, aes(x=vec_degree, y=vec_residuals)) + geom_point()

p_timestep_f
```

