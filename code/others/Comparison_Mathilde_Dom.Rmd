---
title: "Process tracking - last updates"
output: html_notebook
---


# How to make the model run for a Foodweb



# Speciation probability

In Mathilde's code

pars$u_max = 0.15 # Speciation probability

```{r}
# Test if there is speciation
				test_number = runif(1, 0, 1)
				speciation_prob = u_max/(1 + exp(d * (ActualS - I_max)))
				if(test_number < speciation_prob) {
```


In Dom's code

pars$u_max = 0.075 # mutation probability

```{r}
if(runif(1, 0, 1) < u_max) {
```


Mathilde is taking into account ActualS (species number at the current timestep) - I_max (maximal number of spp in the community). d is a constant. umax is an assymptotic speciation rate.




# Establishment probability


First, the number of interactions among the present species needs to be calculated, and this takes into account basals. Mathilde does it with + Bspe and Dom with Sbasal:

```{r}

# Compute the number of interactions among present species
sum_I = sum(I*pres[step,]) + Bspe

```

```{r}

# Compute the number of interactions among present species
sum_I = sum(I*c(rep(1,Sbasal),pres[step,]))

```



Mathilde

```{r}
if(sum_I == 0){
						estab_prob = 0
					}

					if(sum_I > 0){
					  estab_prob = (u_0 + u_1*exp(-a_u*sum_I)) #as facilitation
					}
```

Dom

```{r}
# Compute the probability of successful speciation	
				spec_prob = u_0 + u_1*exp(-a_u*sum_I)
```


-> dont understand well Mathilde's obtion (condition that if no interactions, no possibility to establish) (?) - I think this condition should be only for mutualisms - for mutualistic partners and for predators of preys.



--> For now I'll go with Dom's one




# Extinction probability



Mathilde

```{r}
	if(int == 0) {
			in_I = colSums(L) + Bext*pres_vec
			ext_prob = e_0neg * (1 - exp(-a_eneg*in_I))
		}

	 	if(int == 1) {
			in_I = colSums(L) + Bext*pres_vec
			ext_prob = e_0pos + e_1pos*exp(-a_epos*in_I)
			##print(paste("extinction probability =", ext_prob[1]))
		}
```


Dominique

```{r}
		if(int == 0) {
			in_I = colSums(L)
			ext_prob = e_0neg + e_1neg*(1 - exp(-a_eneg*in_I)) 
		}
	 
	 	if(int == 1) {
			in_I = colSums(L)
			ext_prob = e_0pos + e_1pos*exp(-a_epos*in_I) 
		}

		if(int == 2) {
			in_I = colSums(L)
			out_I = rowSums(L)[(Sbasal+1):(Sbasal+Smax)] 	
			ext_prob = e_0neg + e_1neg*exp(-a_eneg*out_I) + e_0pos + e_1pos*exp(-a_epos*in_I)	
		}
```


First, the probability of extinction for competition is different. In Doms code the formula is different than in Mathilde's - I need to understand how they differ form each other and which one I choose.

Second, to calculate the number of interactions, Dom only uses ColSums, whereas Mathilde also sums the multiplication Bext*pres_vec.



# Basal species

Dominique's code contains basal species.


### Compute Matrix of interactions

Mathilde uses the same function for computing the matrix of interactions, but 
slightly modified to not to include the basal species. So I can tweek Mathilde's 
function to add the basals again, as Dominique does.


Dominique's function

```{r}

# Function to compute the interaction network from a set of traits
get_L_mat = function(basal, pars, traits_mat) {
	with(as.list(pars),{
		L = matrix(0, nr = Smax+Sbasal, nc = Smax)

		# Lower boundary
		low = traits_mat$o - traits_mat$r
		low_mat = matrix(low, nr = Smax+Sbasal, nc = Smax, byrow = TRUE)

		# Upper boundary
		high = traits_mat$o + traits_mat$r
		high_mat = matrix(high, nr = Smax+Sbasal, nc = Smax, byrow = TRUE)	
		S = nrow(traits_mat)

		# Matrix of niche positions
		n_mat = matrix(traits_mat$n, nr = Smax, nc = Smax, byrow = FALSE)

		# Add the basal species
		n_basal = matrix(basal, nr = Sbasal, nc = Smax, byrow = FALSE)
		n_mat = rbind(n_basal, n_mat)

	  	# Test interactions
	  	L[n_mat > low_mat & n_mat < high_mat] = 1
	  	if(Smax > 1) diag(L[(Sbasal+1):(Sbasal+Smax),]) = 0
	  	L
  })
}


```


Mathilde's function



```{r}

# Function to compute the interaction network from a set of traits
get_L_mat = function(pars, traits_mat) {
	with(as.list(pars),{
		L = matrix(0, nr = pars$Smax, nc = pars$Smax)

		# Lower boundary
		low = traits_mat$n - traits_mat$r
		low_mat = matrix(low, nr = pars$Smax, nc = pars$Smax, byrow = TRUE)

		# Upper boundary
		high = traits_mat$n + traits_mat$r
		high_mat = matrix(high, nr = pars$Smax, nc = pars$Smax, byrow = TRUE)
		S = nrow(traits_mat)

		# Matrix of niche positions
		n_mat = matrix(traits_mat$n, nr = pars$Smax, nc = pars$Smax, byrow = FALSE)

		## Add the basal species
		#n_basal = matrix(basal, nr = pars$Sbasal, nc = pars$Smax, byrow = FALSE)
		#n_mat = rbind(n_basal, n_mat)

	  	# Test interactions
	  	L[n_mat > low_mat & n_mat < high_mat] = 1
	  	if(pars$Smax > 1) diag(L) = 0
	  	L
  })
}

```


Making the new function:

In Dominique's code, pars$Sbasal = 25


```{r}


# Function to compute the interaction network from a set of traits
get_L_mat = function(basal, pars, traits_mat) {
	with(as.list(pars),{
		L = matrix(0, nr =  Smax +  Sbasal, nc =  Smax)

		# Lower boundary
		low = traits_mat$n - traits_mat$r
		low_mat = matrix(low, nr =  Smax + Sbasal, nc =Smax, byrow = TRUE)

		# Upper boundary
		high = traits_mat$n + traits_mat$r
		high_mat = matrix(high, nr =  Smax + Sbasal, nc =Smax, byrow = TRUE)
		S = nrow(traits_mat)

		# Matrix of niche positions
		n_mat = matrix(traits_mat$n, nr = Smax, nc = Smax, byrow = FALSE)

		## Add the basal species
		n_basal = matrix(basal, nr = Sbasal, nc = Smax, byrow = FALSE)
		n_mat = rbind(n_basal, n_mat)

	  	# Test interactions
	  	L[n_mat > low_mat & n_mat < high_mat] = 1
	  	if(Smax > 1) diag(L[(Sbasal+1):(Sbasal+Smax),]) = 0
	  	L
  })
}

```



Then, the function in Mathilde's model now requires the arcgument "basal" which are the traits of basal species that Dmonique creates like this:

```{r}
	# Draw the traits of the producers
#	basal = runif(pars$Sbasal, 0, 1)
	basal = runif(pars$Sbasal, 0, 0.2)
```

This is done in the simulation when setting all parameters and values before the loop.



-------------------------------------
One difference I notice is that everytime Dom uses the trait "o", Mathilde uses "n".
-------------------------------------


### Compute interactions per species


Same changes with the function get_L)vec (commpute the interactions of a given species). Mathilde needs to add the basal species:


Doms code

```{r}
# Function to compute the interactions of a given species
get_L_vec = function(basal, pars, traits_mat, traits_mut) {
	with(as.list(pars),{
		L_vec = numeric(Smax+Sbasal)

		# Lower boundary
		low = traits_mut["o"] - traits_mut["r"]

		# Upper boundary
		high = traits_mut["o"] + traits_mut["r"]

		# Vector of niche positions
		n_vec = c(basal, traits_mat$n)

	  	# Test interactions
	  	L_vec[n_vec > as.numeric(low) & n_vec < as.numeric(high)] = 1
	  	L_vec
  })
}
```


Mathilde's code

```{r}
get_L_vec = function(pars, traits_mat, traits_mut) {
	with(as.list(pars),{
		L_vec = numeric(pars$Smax)

		# Lower boundary
		low = as.numeric(traits_mut["n"]) - as.numeric(traits_mut["r"])

		# Upper boundary
		high = as.numeric(traits_mut["n"]) + as.numeric(traits_mut["r"])

		# Vector of niche positions
		n_vec = c(traits_mat$n)

	  	# Test interactions
	  	L_vec[n_vec > as.numeric(low) & n_vec < as.numeric(high)] = 1
	  	L_vec
  })
}

```



Adding basals to Mathilde's code:

```{r}
get_L_vec = function(basal, pars, traits_mat, traits_mut) {
	with(as.list(pars),{
		L_vec = numeric(pars$Smax + pars$Sbasal)

		# Lower boundary
		low = as.numeric(traits_mut["n"]) - as.numeric(traits_mut["r"])

		# Upper boundary
		high = as.numeric(traits_mut["n"]) + as.numeric(traits_mut["r"])

		# Vector of niche positions
		n_vec = c(basal, traits_mat$n)

	  	# Test interactions
	  	L_vec[n_vec > as.numeric(low) & n_vec < as.numeric(high)] = 1
	  	L_vec
  })
}

```




Another change is when computing the matrix of interactions in the loop after performing probabilities of establishment.

Dominique's code works handle the basal species:

```{r}
L[c((Sbasal+1):(Sbasal+Smax)),]= L[c((Sbasal+1):(Sbasal+Smax)),]*cooc 
```

so I add this in Mathilde's code, where she does the same but without taing into account the basals:

```{r}
L = L * cooc
```


--------------------------------
Idea for computing probabilities of extinctions differently for species as preys and as predators, as Dominique does:

```{r}

		if(int == 2) {
			in_I = colSums(L)
			out_I = rowSums(L)[(Sbasal+1):(Sbasal+Smax)] 	
			ext_prob = e_0neg + e_1neg*exp(-a_eneg*out_I) + e_0pos + e_1pos*exp(-a_epos*in_I)	
		}
```

--------------------------------





### Compute interaction probabilities



Mathilde:


```{r}
# Compute the number of interactions among present species
sum_I = sum(I*pres[step,]) + Bspe
```


Dominique:

```{r}
# Compute the number of interactions among present species
sum_I = sum(I*c(rep(1,Sbasal),pres[step,]))	
```


I will use the Dominique one to include the basals
















































