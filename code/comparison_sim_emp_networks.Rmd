---
title: "Measure and compare network metrics from simulated community with empirical ones"
output: html_notebook
---



### cHECK PROPERTIES OF NETWORKS\

First, we need to obtain the networks. We will select those spp present.

```{r}

nrow(reccorded_objecs_success[[6]]$species_present)


## spp names from numbers to letters

net_numbers <- set_sppNames_numbers(reccorded_objecs_success[[6]]$matrix_int[[1]])

net_letters <- convert_sppnames_toletters(net_numbers)


## Crop network for present spp

colnames(reccorded_objecs_success[[6]]$species_present) <- seq(1:1000)

colnames(reccorded_objecs_success[[6]]$species_present) <- chartr("0123456789", "ABCDEFGHIJ", colnames(reccorded_objecs_success[[6]]$species_present))

presents <- reccorded_objecs_success[[6]]$species_present[reccorded_objecs_success[[6]]$steps,]

net_present_spp.letters <- net_letters[names(which(presents == 1)), names(which(presents == 1))]



```


Network metrics

```{r}

library(igraph)

graph <- graph_from_adjacency_matrix(adjmatrix = net_present_spp.letters,
                            mode = "directed")

plot(graph, vertex.size=4, 
     vertex.label=NA, 
     edge.arrow.size= 0.3, 
     layout = layout_on_sphere) 

## compute connectance

S <- vcount(graph)
L <- ecount(graph)

# average number of interactions species
L.S <- L/S

# food web connectance
C <- L/S^2

# MODULARITY

membership_vec <- cluster_walktrap(graph)

m <- modularity(graph, membership(membership_vec))


coords = layout_with_fr(graph)

plot.igraph(graph, vertex.color= membership(membership_vec), layout = coords, 
     vertex.width = 0.1,
     edge.arrow.size=0.3)


# DEGREE DISTRIBUTION


## Node degrees

deg_1 <- degree(graph)

degree_distribution(graph)

t1 <- table (deg_1)
sum(t1)

relafreq_1 <- t1/sum(t1)

barplot_degree.dist <- barplot(relafreq_1, breaks = seq(-1,(max(deg_1)+1), by=0.5),
        xlab = "k", ylab = "Relative frequencies", 
        main = "Degree distribution",
        ylim = range(pretty(c(0,relafreq_1))))

hist_degree.dist <- hist(deg_1, breaks = 0:(max(deg_1)+1),
        xlab = "k", ylab = "Relative frequencies", 
        main = "Degree distribution")


```

```{r}
library("igraph")
library("poweRlaw")
library("ggplot2")


# List of degrees
G.degrees <- degree(graph)

# Let's count the frequencies of each degree
G.degree.histogram <- as.data.frame(table(G.degrees))

# Need to convert the first column to numbers, otherwise
# the log-log thing will not work (that's fair...)
G.degree.histogram[,1] <- as.numeric( paste(G.degree.histogram[,1]))

# Now, plot it!
ggplot(G.degree.histogram, aes(x = G.degrees, y = Freq)) +
  geom_point() +
  scale_x_continuous("Degree\n(nodes with this amount of connections)",
                     breaks = c(1, 3, 10, 30, 100, 300),
                     trans = "log10") +
  scale_y_continuous("Frequency\n(how many of them)",
                     breaks = c(1, 3, 10, 30, 100, 300, 1000),
                     trans = "log10") +
  ggtitle("Degree Distribution (log-log)") +
  theme_bw()



deg <- degree(graph, mode="all")
plot(graph, vertex.size=deg)

hist(deg, breaks=1:vcount(graph)-1, main="Histogram of node degree")


deg.dist <- degree_distribution(graph, cumulative=T, mode="all")
plot( x=0:max(deg), y=1-deg.dist, pch=19, cex=1.2, col="orange",
xlab="Degree", ylab="Cumulative Frequency")


```




## Metrics from empirical networks

see:
https://mlurgi.github.io/networks_for_r/lesson-4.html




# New approach

these metrics used in: https://www.nature.com/articles/s41598-019-54443-0


1. Number of species within the foodweb (S)
2. liks density (L/S)
3. directed connectance (C = L/S2)
4. %T (Top species that have resource species but lack any consumer species)
5. % I (Intermediate species that have both resource and consumer species)
6. % B (Basal species that have consumer species but lack resources species)
7. %C (Cannibal species that eat themselves)
8. %Omn (species that eat species at different trophic levels)
9. Standard deviation of mean generality (GenSD)
10. Standard deviation of mean vulnerability (VulSD)


Reference page: https://rfrelat.github.io/BalticFoodWeb.html


```{r}
library(fluxweb)
library(NetIndices)
```


# Neutral

```{r}
readRDS(file = "neutral_df_scenarios_success.rds")
readRDS(file = "neutral_reccorded_objecs_success.rds")
```



scenario id, parameters changed

```{r}

df_scenarios_success

```



vector of networks (in order of scenario id)


1. get the adjacency matrix of each scenario

```{r}


adj_matrix_list <- list()

for (i in 1:length(reccorded_objecs_success)) {
  
  
  ## spp names from numbers to letters
  
  net_numbers <- set_sppNames_numbers(reccorded_objecs_success[[i]]$matrix_int[[1]])
  
  net_letters <- convert_sppnames_toletters(net_numbers)
  
  
  ## Crop network for present spp
  
  colnames(reccorded_objecs_success[[i]]$species_present) <- seq(1:1000)
  
  colnames(reccorded_objecs_success[[i]]$species_present) <- chartr("0123456789", "ABCDEFGHIJ", colnames(reccorded_objecs_success[[i]]$species_present))
  
  presents <- reccorded_objecs_success[[i]]$species_present[reccorded_objecs_success[[i]]$steps,]
  
  adj_matrix_list[[i]] <- net_letters[names(which(presents == 1)), names(which(presents == 1))]
  
  
  
  
}


```






```{r}

columns <- c("p(est)",
             "p(ext)",
             "S",
             "Link_density",
             "C",
             "perc_tops",
             "perc_int",
             "perc_basals",
             "perc_cannibals",
             "omnivory",
             "mean_gen",
             "sd_gen",
             "mean_vul",
             "sd_vul")

df = data.frame(matrix(nrow = 0, ncol = length(columns))) 
colnames(df) = columns


for (i in 1:length(adj_matrix_list)) {
  
  graph <- graph_from_adjacency_matrix(adjmatrix = adj_matrix_list[[i]],
                                       mode = "directed")
  
  
  # 1. Number of species within the foodweb (S)
  
  S <- gorder(graph)
  
  df[i, "S"] <- S
  
  
  
  
  # 2. links density (L/S)
  
  L <- gsize(graph)
  
  df[i, "Link_density"] <- L/S
  
  
  
  
  # 3. directed connectance (C = L/S2)
  
  df[i, "C"] <- L/(S*S)
  
  
  
  
  # 4. %T (Top species that have resource species but lack any consumer species)
  
  n_tops <- length(V(graph)[degree(g, mode = 'in')>0 & degree(graph, mode = 'out') == 0])
  
  df[i, "perc_tops"] <- n_tops/S*100
  
  
  
  
  
  #5. % I (Intermediate species that have both resource and consumer species)
  
  n_int <- length(V(graph)[degree(graph, mode = 'out')>0 & degree(graph, mode = 'in') > 0])
  
  df[i, "perc_int"] <- n_int/S*100
  
  
  
  
  #6. % B (Basal species that have consumer species but lack resources species)
  
  n_basals <- length(V(graph)[degree(graph, mode = 'out')>0 & degree(graph, mode = 'in') == 0])
  
  df[i, "perc_basals"] <- n_basals/S*100
  
  
  
  
  # 7. %C (Cannibal species that eat themselves)
  
  edge_list <- as_edgelist(graph, names = TRUE)
  
  n_cannibals <- length(which(edge_list[,1] == edge_list[,2]))
  
  df[i, "perc_cannibals"] <- n_cannibals/S*100
  
  
  
  
  
  #8. %Omn (species that eat species at different trophic levels) -> changed for omnivory (general omnivory of the foodweb)
  
  # Compute the trophic level for each node  
  tlnodes <- neighborhood.size(graph,mode="out")
  
  # Calculate the average trophic level of the food web
  TL <- mean(tlnodes)
  
  #Omnivory is based on the calculation of trophic levels, and corresponds to the standard deviation of the trophic levels of a speciesâ€™ prey.
  
  netmatrix <- get.adjacency(graph, sparse=F)
  # Link the trophic level to the interactions
  webtl <- netmatrix*as.vector(tlnodes)
  # Remove the trophic level when no interactions
  webtl[webtl==0] <- NA
  
  #Compute the standard of the trophic levels of prey 
  omninodes <- apply(webtl,2,sd, na.rm=TRUE)
  
  # Average the standard deviation over all taxa (with more than 2 preys)  
  df[i, "omnivory"] <- mean(omninodes, na.rm=TRUE)
  
  
  
  
  
  
  #9. Standard deviation of mean generality (GenSD)
  # Generality
  
  pred <- degree(graph, mode="in")>0 # Identify predator nodes, i.e. taxa with at least one prey
  
  mean_gen <- mean(degree(graph, mode="in")[pred])
  
  df[i, "mean_gen"] <- mean(degree(graph, mode="in")[pred])
  df[i, "sd_gen"] <- sd(degree(graph, mode="in")[pred])
  
  
  
  
  
  # 10. Standard deviation of mean vulnerability (VulSD)
  # Generality
  
  prey <- degree(graph, mode="out")>0 
  
  df[i, "mean_vul"] <- mean(degree(graph, mode="out")[prey])
  df[i, "sd_vul"] <- sd(degree(graph, mode="out")[prey])
  
  
}



df[,"p(est)"] <- df_scenarios_success$p_est
df[,"p(ext)"] <- df_scenarios_success$p_ext


df

```




Vector of frequencies of triad isomorphic classes

```{r}

columns <- as.character(c(1:16))
df_motifs = data.frame(matrix(nrow = 0, ncol = length(columns))) 
colnames(df_motifs) = columns



for (i in 1:length(adj_matrix_list)) {
  
  graph <- graph_from_adjacency_matrix(adjmatrix = adj_matrix_list[[i]],
                                       mode = "directed")
  
  
  v_motifs <- motifs(graph, 3)
  
  df_motifs[i,] <- v_motifs
  
}


df_motifs

```

```{r}

my.theme<-theme(axis.text=element_text(size=12),
                axis.title = element_text(size = 14),
                legend.position = "top",
                legend.text=element_text(size=10),
                legend.title = element_text(size=12),
                plot.title = element_text(face="bold",size=14,margin=margin(0,0,20,0),hjust = 0.5),
                axis.title.y = element_text(margin = margin(t = 0, r = 15, b = 0, l = 0)),
                axis.title.x = element_text(margin = margin(t = 15, r = 0, b = 0, l = 0)))
```





```{r}
library(ggplot2)
library(reshape2)

df_motifs$scenario <- as.character(c(1:nrow(df_motifs)))

df_melted = melt(df_motifs, id.vars = 'scenario')

ggplot(df_melted, aes(x = variable, y = value)) + geom_line(aes(color = scenario, group = scenario))+
  theme_bw()+
  my.theme+
  theme(legend.position = "right")


```

