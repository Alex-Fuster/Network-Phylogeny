---
title: "Foodweb simulation + comparison with empirical networks"
output: html_notebook
---




```{r}

library(igraph)
library(reshape2)
library(ggplot2)
library(ggpubr)

source("../code/functions/functions_fw_new2.R")
source("../code/functions/functions_metrics_networks.R")
source("../code/functions/functions_phylo_signal.R")

# Read table with metrics from empirical foodwebs

net_metr_empirical <- readRDS("../data/net_metrics_empirical.rds")

net_metr_empirical$id <- NULL

net_metr_empirical <- net_metr_empirical[-13,]

df_metrics_emp <- reshape_df_net.metrics(df_metrics = net_metr_empirical,
                       interaction = "empirical")
```
For plotting:

```{r}
my.theme<-theme(axis.text=element_text(size=12),
                axis.title = element_text(size = 14),
                legend.position = "top",
                legend.text=element_text(size=10),
                legend.title = element_text(size=12),
                plot.title = element_text(face="bold",size=14,margin=margin(0,0,20,0),hjust = 0.5),
                axis.title.y = element_text(margin = margin(t = 0, r = 15, b = 0, l = 0)),
                axis.title.x = element_text(margin = margin(t = 15, r = 0, b = 0, l = 0)))
```


Define parameters

```{r}

pars = list()
pars$u_max = 0.075 # mutation probability
pars$u_0 = 1  # 1 for predation & mutualism, 0 for competition
pars$u_1 = -1 # -1 for predation & mutualism, 1 for competition
pars$e_0neg = 0.15 # asymptotic extinction probability with infinite negative interactions
pars$e_1neg = -pars$e_0neg  # Extinction probability with absence of interactions
pars$e_0pos = 0.01 # asymptotic extinction probability with infinite positive interactions
pars$e_1pos = 1 - pars$e_0pos # 1 - e0
pars$a_u = 0.5 # shape of the exponential decay of the colonization - interaction relationship	
pars$a_eneg = 0.025 # shape of the exponential decay of the negative extinction - interaction relationship 
pars$a_epos = 0.5  # shape of the exponential decay of the positive extinction - interaction relationship 
pars$av_r = 0.209 # range of the niche
pars$beta_n = 1 # parameter of the beta distribution 

pars$Sbasal = 30 # number of basal species
pars$Smax = 1000 # Maximal number of species allowed

## pars added from Mathilde's

pars$d = 0.5 # Decrease speed of the establishment probability
pars$I_max = 60 # Maximal number of interactioning species


pars$a_eneg_s = 0.005
pars$e_0neg_s = 0.00015 # asymptotic extinction probability with infinite negative interactions

```


Simulation + metrics comparison with empirical foodwebs

```{r}

##############################
# Run the model
# attach(pars)
#seed = 1
nsteps =  250
n_sims = 3
list_adj_matrix.f <- list()



for (i in 1:n_sims) {
  
  results <- sim_model_bif(seed = runif(1), pars, nsteps = nsteps)
  
  names(results)[1] <- "presence_matrix"
  names(results)[7] <- "network_list"
  names(results)[9] <- "list_anc_dist"
  
  list_adj_matrix.f[[i]] <- get_adjancency_from_simulation.fw_single(list_networks = results$network_list,
                                           nbasals = length(results$basal),
                                           pres_mat = results$presence_matrix)
  
}


# calculate metrics for each simulation

net_metr_sim <- get_network_measures_from_adjacency(list_adj_matrix = list_adj_matrix.f)

# compute table with mean metrics

df_metrics_fw <- reshape_df_net.metrics(df_metrics = net_metr_sim,
                       interaction = "foodweb")


# join with table of empirical networks

# Joining the empirical networks here

df_metrics <- merge(df_metrics_fw,
                    df_metrics_emp,
                    by = "metric")


# plot the results

p_S <- plot_metric_foodweb(df = df_metrics, metric = "S", y_axis = "N species")
p_link.dens <- plot_metric_foodweb(df = df_metrics, metric = "Link_density", y_axis = "L/S")
p_C <- plot_metric_foodweb(df = df_metrics, metric = "C", y_axis = "Connectance")
p_top <- plot_metric_foodweb(df = df_metrics, metric = "perc_tops", y_axis = "% top species")
p_int <- plot_metric_foodweb(df = df_metrics, metric = "perc_int", y_axis = "% intermediate species")
p_basal <- plot_metric_foodweb(df = df_metrics, metric = "perc_basals", y_axis = "% basal species")
p_cannibals <- plot_metric_foodweb(df = df_metrics, metric = "perc_cannibals", y_axis = "% cannibal species")
p_omnivory <- plot_metric_foodweb(df = df_metrics, metric = "omnivory", y_axis = "omnivory")
p_sd_gen <- plot_metric_foodweb(df = df_metrics, metric = "sd_gen", y_axis = "SD generality")
p_sd_vul <- plot_metric_foodweb(df = df_metrics, metric = "sd_vul", y_axis = "SD vulnerability")

plot_metrics_comparison_sim_emp <- ggarrange(
  p_S,
  p_link.dens,
  p_C,
  p_top,
  p_int,
  p_basal,
  p_cannibals,
  p_omnivory,
  p_sd_gen,
  p_sd_vul,
  
  nrow = 5,
  ncol = 2
  
)

plot_metrics_comparison_sim_emp







```

```{r}



graph <- graph_from_adjacency_matrix(adjmatrix = list_adj_matrix.f[[1]],
                                         mode = "directed")

degree <- degree(graph)
 
    
    S <- vcount(graph)
    
    df[i, "S"] <- S
    
    
    
    
    # 2. links density (L/S)
    
    L <- ecount(graph)
    
    df[i, "Link_density"] <- L/S
    
    
    
    
    # 3. connectance (C = L/S2)
    
    df[i, "C"] <- C <- L/S^2
    
    

    
    
    # 4. %T (Top species that have resource species but lack any consumer species)
    
    n_tops <- length(V(graph)[degree(graph, mode = 'in')>0 & degree(graph, mode = 'out') == 0])
    
    df[i, "perc_tops"] <- n_tops/S*100
    
    
    
    
    
    #5. % I (Intermediate species that have both resource and consumer species)
    
    n_int <- length(V(graph)[degree(graph, mode = 'out')>0 & degree(graph, mode = 'in') > 0])
    
    df[i, "perc_int"] <- n_int/S*100
    
    
    
    
    #6. % B (Basal species that have consumer species but lack resources species)
    
    n_basals <- length(V(graph)[degree(graph, mode = 'out')>0 & degree(graph, mode = 'in') == 0])
    
    df[i, "perc_basals"] <- n_basals/S*100
    
    
    
    
    # 7. %C (Cannibal species that eat themselves)
    
    edge_list <- as_edgelist(graph, names = TRUE)
    
    n_cannibals <- length(which(edge_list[,1] == edge_list[,2]))
    
    df[i, "perc_cannibals"] <- n_cannibals/S*100
    
    
    
    
    
    #8. %Omn (species that eat species at different trophic levels) -> changed for omnivory (general omnivory of the foodweb)
    
    # Compute the trophic level for each node  
    tlnodes <- neighborhood.size(graph,mode="out")
    
    # Calculate the average trophic level of the food web
    TL <- mean(tlnodes)
    
    #Omnivory is based on the calculation of trophic levels, and corresponds to the standard deviation of the trophic levels of a species' prey.
    
    netmatrix <- get.adjacency(graph, sparse=F)
    # Link the trophic level to the interactions
    webtl <- netmatrix*as.vector(tlnodes)
    # Remove the trophic level when no interactions
    webtl[webtl==0] <- NA
    
    #Compute the standard of the trophic levels of prey 
    omninodes <- apply(webtl,2,sd, na.rm=TRUE)
    
    # Average the standard deviation over all taxa (with more than 2 preys)  
    df[i, "omnivory"] <- mean(omninodes, na.rm=TRUE)
    
    
    
    
    
    
    #9. Standard deviation of mean generality (GenSD)
    # Generality
    
    pred <- degree(graph, mode="in")>0 # Identify predator nodes, i.e. taxa with at least one prey
    
    df[i, "mean_gen"] <- mean(degree(graph, mode="in")[pred])
    df[i, "sd_gen"] <- sd(degree(graph, mode="in")[pred])
    
    
    
    
    
    # 10. Standard deviation of mean vulnerability (VulSD)
    # Generality
    
    prey <- degree(graph, mode="out")>0 
    
    df[i, "mean_vul"] <- mean(degree(graph, mode="out")[prey])
    df[i, "sd_vul"] <- sd(degree(graph, mode="out")[prey])
    
    
    # frequency distribution
    
    
    
    
    
```

```{r}

mat_test <- list_adj_matrix.f[[1]]

     vec_shared_prey <- c()
      
      for (i in 1:ncol(m)) {
        
            vec_shared_prey[i] <- mean(rowSums(m)*m[,i])
        
      }
     
     
     
m <- matrix(0, 10, 5)
m <-apply(m, c(1, 2), function(x) sample(c(0, 1), 1))
     







  npred = ncol(m)
  
  mat.new <- matrix(0, nrow = nrow(m), ncol = ncol(m))

for(i in 1:ncol(m)) {
  
  
  for (j in 1:nrow(m)) {
    
    
    
    mat.new[j,i] <- m[j,i]*(sum(m[j,])/npred)
    
  }
  
}
  
 vec_competition_pred <- colSums(mat.new)



compute_vec_comp_pred(m)

```

