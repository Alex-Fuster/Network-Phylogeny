---
title: "Obtain phylogenetic and interaction distances"
output: html_notebook
---

```{r}
#source("../Original_code/functions/tree_functions.R")
#source("../Original_code/functions/phylo_functions.R")
source("AF_code/AF_functions_tree.R")
library(ape)
library(apTreeshape)
library(aricode)
library(igraph)
library(ggplot2)
library("vegan")
```




### Load simulation data


```{r}

load("./list_res_fw2_1.Rdata")




#names(list_res) = c("simulation1", "simulation2")

list_simulation1 <- list_res$simulation1


# count number of timesteps where there were spp

n_steps <- length(list_simulation1$network_list)

```


The presence_matrix (rows = timesteps, cols = species, entries = 1,0) has extra timesteps in case the simulation is longer (max = 350), so I crop it to the number of timesteps in the simulation:

```{r}

presence_matrix <- list_simulation1$presence_matrix

presence_matrix <- presence_matrix[1:n_steps,]

```



#### Discard timesteps where phylogenetic distances cant be calculated

It requires at leas 3 species to compute the phylogenetic distances.
Check the timestep from which we can make the calculations by looking at the presence_matrix and see which matrices (or timesteps) have less than 3 spp.

```{r}

non.valid_timesteps_phylo_distance <- c(which(rowSums(presence_matrix) < 3))

print(paste("timesteps 1 to", length(non.valid_timesteps_phylo_distance), "will be discarted as they have less than 3 spp"))

```




#### homogenize elements to start from valid timesteps

Discard those timesteps with less than 3 spp in both the list_anc_dist table (ancestry table) and the network_list:

```{r}

# ancestry-distances table

list_anc_dist <- list_simulation1$list_anc_dist[-non.valid_timesteps_phylo_distance]



# Network list

network_list <- list_simulation1$network_list[-non.valid_timesteps_phylo_distance]







## ------------------- Check

if (length(which(is.null(list_simulation1$network_list))) > 0) {
  
  print("check - null network somewhere")
} else {
  print("all good - no null networks")
}


if(length(list_anc_dist) == length(network_list)){
  
  print("all good - distance-ancestry table and network list have the same length")
} else {
  
  print("PROBLEM")
}


```



## Convert spp names from numbers to letters


Species names in both the ancestry table and the networks are numbers. Convert it into letters with the function **change_sppnames_letters_ancdist.table()** for the ancestry table, and **set_sppNames_numbers()** (because matrices lack colnames and rownames) and **convert_sppnames_toletters()** for the network list:

```{r}

## ancestry-distances table

list_anc_dist_letters <- lapply(list_anc_dist, change_sppnames_letters_ancdist.table)


## Network list 

list_networks_sppnames_numbers <- lapply(network_list, set_sppNames_numbers)

#### convert numbers to letters

list_networks_sppnames_letters <- lapply(list_networks_sppnames_numbers, convert_sppnames_toletters)






## ------------------- Check


if(length(list_anc_dist_letters) == length(list_networks_sppnames_letters)){
  
  print("all good - distance-ancestry table with letters and network list with leters have the same length")
} else {
  
  print("PROBLEM")
}
```




## Loop for obtaining phylogenetic distances:


Without distinguishing predators and preys:

```{r}

list_newick <- list()
list_trees <- list()
list_newick_tails <- list()
list_dist.phylo <- list()




for (i in 1:length(list_anc_dist_letters)) {
  
  
  print(sprintf("step %s", i))
  
  list_newick[[i]] <- ToPhylo(list_anc_dist_letters[[i]])
  
  list_newick_tails[[i]] <- paste(list_newick[[i]], "root")
  
  list_trees[[i]] <- read.tree(text = sub("A root",";",list_newick_tails[[i]]))
  
  list_dist.phylo[[i]] <- cophenetic.phylo(list_trees[[i]])
  

}







## ------------------- Check

if (length(which(unlist(lapply(list_dist.phylo, is.null)) == TRUE)) == 0) {
  
  print("all good - no nulls")
} else {
  
  print("PROBLEM")
  
}



if (length(list_dist.phylo) == length(list_networks_sppnames_letters)){
  
  print("all good - list phylo dist with letters and list interactions with letters have the same length")
  
}else{
  
  print("PROBLEM")
  
}


```



## Retain only present species in network matrices

For phylogenetic distance matrices, the spp for which distances are calculated are already only the ones present.

But the interaction matrices are 1000 x 1000 (all spp possible), so I need to crop them to retain only present species at each timestep, and test that these correspond to the ones present in the phylogenetic distance matrices at the corresponding timestep.


I use the presence_matrix to retain the species present at each timestep in each network from the network list. So first I need to convert the spp names of the presence_matrix to letters so that they can match with those of the network. Second, I will discard the timesteps already discarted in the phylogenetic distance matrices list and in the network list so that the presence_matrix match in the length of timesteps with them.


```{r}

# Set the same spp names for the presence_matrix than for the interacion matrices


colnames(presence_matrix) <- seq(1:1000)

colnames(presence_matrix) <- chartr("0123456789", "ABCDEFGHIJ", colnames(presence_matrix))



## ------------------- Check

if(length(which(colnames(presence_matrix) != colnames(list_networks_sppnames_letters[[1]]))) == 0){
  
  print("all good - spp names in presence_matrix correspond to spp names in network list")
  
} else {
  
  print("PROBLEM")
} 





# Discard same timesteps (rows) than the discarted phylogenetic distance matrices

presence_matrix <- presence_matrix[-non.valid_timesteps_phylo_distance,]




## ------------------- Check

if(nrow(presence_matrix) == length(list_networks_sppnames_letters) & 
   nrow(presence_matrix) == length(list_dist.phylo)){
  
  print("all good - presence matrix, list phylo dist and list interaction networks have the same n_steps")
  
} else {
  
  print("PROBLEM")
}


```


Now that the presence_matrix has the spp names with letters and retains the same timesteps than the network list, I will use it to retain only the species present at each timestep in each 1000 x 1000 network:

```{r}

## crop the interaction matrix with present spp

list_net_present_spp.letters <- list()

for (i in 1:length(list_networks_sppnames_letters)) {
  
 list_net_present_spp.letters[[i]] <- list_networks_sppnames_letters[[i]][names(which(presence_matrix[i,] == 1)), names(which(presence_matrix[i,] == 1))]
  
}


```






## Compute interaction distances (NMI)


I will use the function **compute_nmi_aricode_pred()** for predators and **compute_nmi_aricode_prey()** for preys (their differ in whether the NMI is computed for columns or rows, respectively). These compute the NMI using the aricode package.


```{r}


## DISTANCES AS PREDATORS (columns)


list_interact_distances_pred <- lapply(list_net_present_spp.letters, FUN = compute_nmi_aricode_pred)


## DISTANCES AS PREYS (rows)

list_interact_distances_prey <- lapply(list_net_present_spp.letters, FUN = compute_nmi_aricode_prey)



```


Some species have NAN in their diagonal. I make sure this doesnt happen by setting the diagonal to ones with the function **diag_to1()**:


```{r}

list_interact_distances_pred <- lapply(list_interact_distances_pred, FUN = diag_to0)

list_interact_distances_prey <- lapply(list_interact_distances_prey, FUN = diag_to0)

```



Now I have the phylogenetic distance matrices in list_dist.phylo, and the interaction distances in list_interact_distances_pred, list_interact_distances_prey, and list_interact_distances_mean.


Check that both the list of distance matrices for interactions and for phylogeny have the same length:

```{r}


if(length(list_dist.phylo) == length(list_interact_distances_pred) &
   length(list_dist.phylo) == length(list_interact_distances_prey)) {
  
  print("all good - list phylo dist and lists interact dist have the same length")
  
} else {
  
  print("PROBLEM")
  
}


```


Phylogenetic distance matrices retain the extinct species together with the present ones. The following code is just a demonstration:

```{r}

df.test.phylo <- as.data.frame(list_dist.phylo[[15]])
df.test.int <- as.data.frame(list_interact_distances_pred[[15]])

data_new.phylo <- df.test.phylo[order(names(df.test.phylo)) , order(names(df.test.phylo))]
data_new.int <- df.test.int[order(names(df.test.int)) , order(names(df.test.int))]

length(colnames(data_new.int)) == length(colnames(data_new.phylo))

```

Therefore, I need to retain only present species in the phylogenetic distance matrices. 




## For phylogenetic distance matrices, retain only those species present

To do this,

- 1st - order the names of columns and rows of both phylogenetic and interaction distance matrices so that they coincide
- 2nd - Retain in the phylo-distance matrix only those species names that the interaction distance matrix has. This way, I will be retaining only the present species (remember the interaction distance matrices have already retained the present species only when we used the presence_matrix for it)



```{r}

list_dist.phylo_pres <- list()

for (i in 1:length(list_dist.phylo)) {
  
  spp_present <- colnames(list_interact_distances_pred[[i]])
  list_dist.phylo_pres[[i]] <- list_dist.phylo[[i]][spp_present ,spp_present] 
  
  
}


```



```{r}


## Check that now phylo and interaction distance matrices have the same number of spp, same names, and in the same order


if (length(which(check_colnames_lists(list_dist.phylo_pres, list_interact_distances_pred) == FALSE)) == 0) {
  
  print("all good - names in phylo dist matrices and interaction matrices pred match")
  
} else {
  
  print("PROBLEM")
  
}


if (length(which(check_colnames_lists(list_dist.phylo_pres, list_interact_distances_prey) == FALSE)) == 0) {
  
  print("all good - names in phylo dist matrices and interaction matrices prey match")
  
} else {
  
  print("PROBLEM")
  
}




```


NOW I'M READY TO COMPUTE CORRELATION



# Compute MDS


First, I need to solve the following problem:

Some species have all 0 in their interactions (either as prey (if all 0 in the row, top predators) or predators (if all 0 in the column, basal spp)). When two spp having all 0 compare with each other, they give NaN instead of 0 (the (1-NMI) should be 0 as they have the same vector of interactions).

Therefore, I assign a 0 to all NaN found.

[[ CHECK THIS ]]


```{r}

list_interact_distances_pred_corrected <- list()

for (i in 1:length(list_interact_distances_pred)) {
  
  list_interact_distances_pred_corrected[[i]] <- convet_nan_to_0_matrix(matrix = list_interact_distances_pred[[i]],
                       marg = 2) # 1 (rows), 2 (col), or c(1,2)
  
}


list_interact_distances_prey_corrected <- list()

for (i in 1:length(list_interact_distances_prey)) {
  
  list_interact_distances_prey_corrected[[i]] <- convet_nan_to_0_matrix(matrix = list_interact_distances_prey[[i]],
                       marg = 1) # 1 (rows), 2 (col), or c(1,2)
  
}



if(length(list_interact_distances_prey_corrected) == length(list_interact_distances_pred_corrected) &
   length(list_interact_distances_prey_corrected) == length(list_dist.phylo_pres)){
  
  print("all good - lists of phylo dist and interactions have the same length")
  
} else {
  
  print("PROBLEM")
  
}


```


To compute the overall distances between species I calculate the mean between the distances as preys and as predators. I do this by looping through the lists (predator distance matrices list, prey distance matrices list), so selecting one matric from each at a given timestep, and computing the mean between them with the function **compute_mean_two_mat_from_list()**:

```{r}

list_interact_distances_mean_corrected <- list()


for (i in 1:length(list_interact_distances_pred_corrected)) {
  
 pair_mat <- list(list_interact_distances_pred_corrected[[i]], list_interact_distances_prey_corrected[[i]])
  
 list_interact_distances_mean_corrected[[i]] <- compute_mean_two_mat_from_list(list = pair_mat)
  
}


if(length(list_interact_distances_mean_corrected) == length(list_dist.phylo_pres)){
  
  print("all good - lists of phylo dist and mean interactions have the same length")
  
} else {
  
  print("PROBLEM")
  
}

```


Now I can compute the MDS:


```{r}

# compute mds

list_mds.phy <- list()
list_mds.int_pred <- list()
list_mds.int_prey <- list()
list_mds.int_mean <- list()



for (i in 1:length(list_dist.phylo_pres)) {

list_mds.phy[[i]] <- monoMDS(list_dist.phylo_pres[[i]], y = cmdscale(list_dist.phylo_pres[[i]])) 

list_mds.int_pred[[i]] <- monoMDS(list_interact_distances_pred_corrected[[i]], y = cmdscale(list_interact_distances_pred_corrected[[i]]))

list_mds.int_prey[[i]] <- monoMDS(list_interact_distances_prey_corrected[[i]], y = cmdscale(list_interact_distances_prey_corrected[[i]]))

list_mds.int_mean[[i]] <- monoMDS(list_interact_distances_mean_corrected[[i]], y = cmdscale(list_interact_distances_mean_corrected[[i]]))


  
}


```





# Compute correlation - Procrustes test

I compute a procrustes correlation between interaction distances as predators, preys, or the mean, and the phylogenetic distances. To do this, I use the **protest** and **procrustes** functions from the vegan package.


```{r}

protest_pred <- list()
procrustes_pred <- list()

protest_prey <- list()
procrustes_prey <- list()

protest_mean <- list()
procrustes_mean <- list()


for (i in 1:length(list_dist.phylo_pres)) {
  
  protest_pred[[i]] <- protest(list_mds.int_pred[[i]], list_mds.phy[[i]])
  
  procrustes_pred[[i]] <- procrustes(list_mds.int_pred[[i]],list_mds.phy[[i]])
  
  
}

for (i in 1:length(list_dist.phylo_pres)) {
  
  protest_prey[[i]] <- protest(list_mds.int_prey[[i]], list_mds.phy[[i]])
  
  procrustes_prey[[i]] <- procrustes(list_mds.int_prey[[i]],list_mds.phy[[i]])
  
  
}

for (i in 1:length(list_dist.phylo_pres)) {
  
  protest_mean[[i]] <- protest(list_mds.int_mean[[i]], list_mds.phy[[i]])
  
  procrustes_mean[[i]] <- procrustes(list_mds.int_mean[[i]],list_mds.phy[[i]])
  
  
}




```



## Create dataframe results


I store the correlation and Pvalue from the tests.


```{r}

protest_pval_pred <- c()
protest_corr_pred <- c()
protest_t_pred <- c()

protest_pval_prey <- c()
protest_corr_prey <- c()
protest_t_prey <- c()

protest_pval_mean <- c()
protest_corr_mean <- c()
protest_t_mean <- c()

for (i in 1:length(protest_mean)) {
  
  protest_pval_pred[i] <- protest_pred[[i]]$signif
  
  protest_corr_pred[i] <-protest_pred[[i]]$t0
  
  protest_t_pred[i] <-mean(protest_pred[[i]]$t)
  
  
  protest_pval_prey[i] <- protest_prey[[i]]$signif
  
  protest_corr_prey[i] <-protest_prey[[i]]$t0
  
  protest_t_prey[i] <-mean(protest_prey[[i]]$t)
  
  
  protest_pval_mean[i] <- protest_mean[[i]]$signif
  
  protest_corr_mean[i] <-protest_mean[[i]]$t0
  
  protest_t_mean[i] <-mean(protest_mean[[i]]$t)
  
  
}

discarted_timesteps <- length(list_simulation1$network_list) - length(protest_mean)

timesteps = (discarted_timesteps+1):length(list_simulation1$network_list)


df_signal_time <- data.frame(timesteps,
                            protest_pval_pred,protest_corr_pred,protest_t_pred,
                            protest_pval_prey,protest_corr_prey,protest_t_prey,
                             protest_pval_mean,protest_corr_mean,protest_t_mean)

df_signal_time$sign_pred <- with(df_signal_time, ifelse(protest_pval_pred < 0.051, 'sign', 'non.sign'))
df_signal_time$sign_prey <- with(df_signal_time, ifelse(protest_pval_prey < 0.051, 'sign', 'non.sign'))
df_signal_time$sign_mean <- with(df_signal_time, ifelse(protest_pval_mean < 0.051, 'sign', 'non.sign'))


df_signal_time


```


```{r}

#save(df_signal_time, file = "../foodweb_test/df_signal_time.RData")

load("../foodweb_test/df_signal_time.RData")

df_signal_time

```




### Plot phylogenetic signal through time

```{r}


my.theme<-theme(axis.text=element_text(size=12),
                axis.title = element_text(size = 14),
                legend.position = "top",
                legend.text=element_text(size=10),
                legend.title = element_text(size=12),
                plot.title = element_text(face="bold",size=14,margin=margin(0,0,20,0),hjust = 0.5),
                axis.title.y = element_text(margin = margin(t = 0, r = 15, b = 0, l = 0)),
                axis.title.x = element_text(margin = margin(t = 15, r = 0, b = 0, l = 0)))


p_pred <- ggplot(df_signal_time, aes(x=timesteps, y=protest_t_mean)) +
       geom_line(color="black", linetype="twodash")+
  #geom_point(aes(fill = sign_mean, color=sign_mean), size=2, alpha = 0.7) +
  theme_bw()+
    my.theme+
    scale_colour_manual(values = c("black", "red"))+
    ggtitle("as predators")+
xlab("timesteps")+
  ylab("Phylogenetic signal")


p_prey <- ggplot(df_signal_time, aes(x=timesteps, y=protest_t_mean)) +
       geom_line(color="black", linetype="twodash")+
  #geom_point(aes(fill = sign_mean, color=sign_mean), size=2, alpha = 0.7) +
  theme_bw()+
    my.theme+
    scale_colour_manual(values = c("black", "red"))+
    ggtitle("as preys")+
xlab("timesteps")+
  ylab("Phylogenetic signal")

p_mean <- ggplot(df_signal_time, aes(x=timesteps, y=protest_t_mean)) +
       geom_line(color="black", linetype="twodash")+
  #geom_point(aes(fill = sign_mean, color=sign_mean), size=2, alpha = 0.7) +
  theme_bw()+
    my.theme+
    scale_colour_manual(values = c("black", "red"))+
    ggtitle("foodweb")+
xlab("timesteps")+
  ylab("Phylogenetic signal")






```


### Plot species richness through time

```{r}
# SHOW ALSO NUMBER OF SPECIES IN THE GRAPH


n_spp_time <- c()

for (i in 1:nrow(presence_matrix)) {
  
  n_spp_time[i] <- length(which(presence_matrix[i,] == 1))
  
}

df_signal_time$nspp <- n_spp_time


p.spp <- ggplot(df_signal_time, aes(x=timesteps, y = nspp)) +
  geom_line(color="black", linetype="twodash") +
  theme_bw()+
  my.theme+
  scale_colour_manual(values = c("black", "red"))+
  xlab("timesteps")+
  ylab("N species")

p.spp

```




```{r}

library(ggpubr)

ggarrange(p_mean + rremove("xlab"), p.spp, 
             ncol = 1, nrow = 2
             )

ggsave("foodweb_result_phylo.time_1sim.png", 
       height = 7,
       width = 7)

```


# NEGATIVE INTERACTIONS



### Load simulation data


```{r}

load("../Data/Negative_interactions/list_res_neg_2.Rdata")

names(list_res) = c("simulation1", "simulation2")

list_simulation1 <- list_res$simulation1


# List for table ancestry-distances and networks
# The first element of both is NULL, so we eliminated it

list_anc_dist <- list_simulation1$list_anc_dist[-1]
network_list <- list_simulation1$network_list[-1]

length(list_anc_dist) == length(network_list)
```



## Convert spp names from numbers to letters

```{r}

## Ancestry-distance

list_anc_dist_letters <- lapply(list_anc_dist, change_sppnames_letters_ancdist.table)


## Interactions

#### 1st, set names as numbers (index of columns and rows)

# WARING - Eliminating first timestep

list_networks_sppnames_numbers <- lapply(network_list, set_sppNames_numbers)

#### 2nd, convert numbers to letters

list_networks_sppnames_letters <- lapply(list_networks_sppnames_numbers, convert_sppnames_toletters)



length(list_anc_dist_letters) == length(list_networks_sppnames_letters)
```




#### Loop for obtaining phylogenetic distances:


Distances can only be calculated from the 3rd matrix in advance, because there is no more than two species until then. So the first two matrix are NULL and we will eliminate them.

We eliminated timestep 1 at the beggining of the code. Eliminating now the 1st (timestep2) and 2nd (timestep3) matrices means that we retain from timestp 4 in advance.

```{r}

list_newick <- list()
list_trees <- list()
list_newick_tails <- list()
list_dist.phylo <- list()


## Can't calculate distances with only 1 spp, so I need to start from the 6th matrix, so timestep 7

for (i in 6:length(list_anc_dist_letters)) {
  
  
  print(sprintf("step %s", i))
  
  list_newick[[i]] <- ToPhylo(list_anc_dist_letters[[i]])
  
  list_newick_tails[[i]] <- paste(list_newick[[i]], "root")
  
  list_trees[[i]] <- read.tree(text = sub("A root",";",list_newick_tails[[i]]))
  
  list_dist.phylo[[i]] <- cophenetic.phylo(list_trees[[i]])
  

}




# Eliminate first five matrices (timestep 2 to 6) that are NULL

list_dist.phylo <- list_dist.phylo[-c(1:5)]


length(list_dist.phylo) # 170
```





#### Interaction distances

We eliminate the 1st and 2nd matrix (timestep 2 and 3) as we did for the list of phylogenetic distance matrices so that we can compare the lists later.

```{r}

list_networks_sppnames_letters <- list_networks_sppnames_letters[-c(1:5)]

length(list_networks_sppnames_letters) # 170

# Compute distances

list_dist_chisq<- lapply(list_networks_sppnames_letters, compute_chisq)

# Only from the 5th matrix, so timestep 7

```

PROBLEM HERE - I receive the following waring:

Warning in vegdist(matrix[-which(rowSums(matrix) == 0), ], method = "chisq",  :
  data have empty species which influence the results in
                 method "chisq"



WARNING: the 6th and 7th matrices  (so timesteps 13 and 14) dont have species and therefore I cant calculate distances from them. So I eliminate these matrices here, and therefore also in the list of phylogenetic distances.

```{r}
list_dist_chisq <- list_dist_chisq[-c(6,7)] 

list_dist.phylo <- list_dist.phylo[-c(6,7)]

length(list_dist_chisq) == length(list_dist.phylo) # 168
```




------------------------------------------------------------

Now I have the phylogenetic distance matrices in list_dist.phylo, and the interaction distances in list_dist_chisq.


Check that both the list of distance matrices for interactions and for phylogeny have the same length:

```{r}
length(list_dist_chisq[[12]]) == length(list_dist.phylo[[12]])
```


Example to show that phylogenetic distance matrices retain the extinct species together with the present ones.

```{r}

df.test.phylo <- as.data.frame(list_dist.phylo[[174]])
df.test.chisq <- as.data.frame(list_dist_chisq[[174]])

data_new.phylo <- df.test.phylo[order(names(df.test.phylo)) , order(names(df.test.phylo))]
data_new.chisq <- df.test.chisq[order(names(df.test.chisq)) , order(names(df.test.chisq))]

colnames(data_new.chisq)

colnames(data_new.phylo)
```


Therefore, I need to 1st order the names of columns and rows of both phylo and interaction distance matrices so that they coincide, and then select only those species present to compare the matrices. The way I will select those species present is by telling the phylo-distance matrix to retain only those species names that the interaction distance matrix has:


-------------------------------------------------------------



## Order column and row spp names


```{r}
list_dist.phylo_df <- lapply(list_dist.phylo, as.data.frame)
list_dist_chisq_df <- lapply(list_dist_chisq, as.data.frame)


list_dist.phylo_df.ord <- lapply(list_dist.phylo_df, order_col.row_names)
list_dist_chisq_df.ord <- lapply(list_dist_chisq_df, order_col.row_names)

```

## For phylogenetic distance matrices, retain only those species present

Species present are those present in the interaction distance matrix.

```{r}
# Select only spp present for phylogenetic distance matrix

list_dist.phylo_df_pres <- list()

for (i in 1:length(list_dist.phylo_df.ord)) {
  
  spp_present <- colnames(list_dist_chisq_df.ord[[i]])
  list_dist.phylo_df_pres[[i]] <- list_dist.phylo_df.ord[[i]][spp_present ,spp_present] 
  
  
}

## Check that now phylo and interaction distance matrices have the same number of spp, same names, and in the same order


colnames(list_dist.phylo_df_pres[[100]]) == colnames(list_dist_chisq_df.ord[[100]])

```



NOW I'M READY TO COMPUTE CORRELATION



# Compute MDS


WARNING: I can't compute MDS with ~2 spp, so I eliminate from matrix 1 to 5th (timestep 7 to 11) which can't be analysed. 

So in total I eliminated timesteps from 1 to 11, 13 and 14.

```{r}

# convert to matrix

list_dist_chisq_mat <- lapply(list_dist_chisq_df.ord, as.matrix)
list_dist.phylo_mat <- lapply(list_dist.phylo_df_pres, as.matrix)


## Eliminate until 5th matrix - too few spp to compute MDS

list_dist_chisq_mat <- list_dist_chisq_mat[-c(1:5)]
list_dist.phylo_mat <- list_dist.phylo_mat[-c(1:5)]



# compute mds

list_mds.int <- list()
list_mds.phy <- list()


# Compute NMS

for (i in 1:length(list_dist_chisq_mat)) {
  
list_mds.int[[i]] <- monoMDS(list_dist_chisq_mat[[i]], y = cmdscale(list_dist_chisq_mat[[i]]))
list_mds.phy[[i]] <- monoMDS(list_dist.phylo_mat[[i]], y = cmdscale(list_dist.phylo_mat[[i]]))
  
}
```


# Compute correlation


already have distance matrices computed (chisq, phylo)

PROBLEM:

I receive the following waring message when computing the protest() in the loop

'nperm' >= set of all permutations: complete enumeration.
Set of permutations < 'minperm'. Generating entire set.

```{r}

protest <- list()
procrustes <- list()

for (i in 1:length(list_dist.phylo_mat)) {
  
  protest[[i]] <- protest(list_mds.int[[i]], list_mds.phy[[i]])
  
  procrustes[[i]] <- procrustes(list_mds.int[[i]],list_mds.phy[[i]])
  
  
}



## it starts from timestep 8

protest_pval <- c()
protest_corr <- c()

for (i in 1:length(protest)) {
  
  protest_pval[i] <- protest[[i]]$signif
  
  protest_corr[i] <-protest[[i]]$t0

  
}


timesteps <- 14:length(list_simulation1$list_anc_dist)

df_signal_time <- data.frame(timesteps,protest_pval,protest_corr)

df_signal_time$sign <- with(df_signal_time, ifelse(protest_pval < 0.051, 'sign', 'non.sign'))


df_signal_time

```

### Plot phylogenetic signal through time

```{r}

library(ggplot2)

my.theme<-theme(axis.text=element_text(size=12),
                axis.title = element_text(size = 14),
                legend.position = "top",
                legend.text=element_text(size=10),
                legend.title = element_text(size=12),
                plot.title = element_text(face="bold",size=14,margin=margin(0,0,20,0),hjust = 0.5),
                axis.title.y = element_text(margin = margin(t = 0, r = 15, b = 0, l = 0)),
                axis.title.x = element_text(margin = margin(t = 15, r = 0, b = 0, l = 0)))


p_neg <- ggplot(df_signal_time, aes(x=timesteps, y=protest_corr)) +
       geom_line()+
  geom_point(aes(fill = sign, color=sign), size=2, alpha = 0.7) +
  theme_bw()+
    my.theme+
    scale_colour_manual(values = c("black", "red"))+
    ggtitle("Phylogenetic signal through time (-)")+
xlab("timesteps")+
  ylab("Phylogenetic signal")


p_neg
```


### Plot species richness through time

```{r}
# SHOW ALSO NUMBER OF SPECIES IN THE GRAPH

presence_matrix <- list_simulation1$presence_matrix[14:length(list_simulation1$list_anc_dist),] # select the timesteps we are analysing (from 8 in advance)

n_spp_time <- c()

for (i in 1:nrow(presence_matrix)) {
  
  n_spp_time[i] <- length(which(presence_matrix[i,] == 1))
  
}

df_signal_time$nspp <- n_spp_time




p.spp_neg <- ggplot(df_signal_time, aes(x=timesteps, y = nspp)) +
  geom_line(color="black", linetype="twodash") +
  theme_bw()+
  my.theme+
  scale_colour_manual(values = c("black", "red"))+
  ggtitle("Species richness through time (-)")+
  xlab("timesteps")+
  ylab("N species")

p.spp_neg

```




```{r}

library(gridExtra)

grid.arrange(p_neg, p.spp_neg, 
             ncol = 1, nrow = 2)



ggsave(arranged.plots, "Neg_signal.time.png", height = 15, width = 20)
```










